<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Chat con PDFs (RAG)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
    }

    :root {
      --bg-main: #020617;
      --card-bg: #020617f2;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.12);
      --accent-2: #8b5cf6;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --surface-soft: #020617;
      --radius-lg: 16px;
      --radius-full: 999px;
      --shadow-soft: 0 24px 60px rgba(0, 0, 0, 0.7);
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow-x: hidden;
    }

    .bg-aurora {
      position: fixed;
      inset: 0;
      z-index: -2;
      overflow: hidden;
      pointer-events: none;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
    }

    .aurora-blob {
      position: absolute;
      width: 420px;
      height: 420px;
      border-radius: 50%;
      filter: blur(60px);
      opacity: 0.65;
      mix-blend-mode: screen;
      animation: float 18s ease-in-out infinite alternate;
    }

    .aurora-blob:nth-child(1) {
      background: #4c1d95;
      top: -80px;
      left: -120px;
      animation-delay: 0s;
    }

    .aurora-blob:nth-child(2) {
      background: #0369a1;
      top: 40%;
      right: -140px;
      animation-delay: 3s;
    }

    .aurora-blob:nth-child(3) {
      background: #15803d;
      bottom: -160px;
      left: 10%;
      animation-delay: 6s;
    }

    @keyframes float {
      0% {
        transform: translate3d(0, 0, 0) scale(1);
      }
      50% {
        transform: translate3d(20px, -20px, 0) scale(1.05);
      }
      100% {
        transform: translate3d(-10px, 20px, 0) scale(1.1);
      }
    }

    .page-shell {
      width: 100%;
      max-width: 1024px;
      margin: 0 auto;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 280px) minmax(0, 1fr);
      gap: 18px;
    }

    @media (max-width: 768px) {
      body {
        padding: 12px;
      }
      
      .page-shell {
        margin-top: 50px;
      }

      .layout {
        grid-template-columns: minmax(0, 1fr);
        gap: 14px;
      }

      .card {
        padding: 16px 14px 18px;
      }

      .answer-content-wrapper {
        max-height: 50vh;
      }

      .structured-table-wrapper {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
      }

      .structured-table {
        min-width: 600px;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      body {
        padding: 16px;
      }

      .layout {
        grid-template-columns: minmax(0, 240px) minmax(0, 1fr);
        gap: 16px;
      }

      .card {
        padding: 18px 16px 20px;
      }
    }

    .card {
      background: var(--card-bg);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: var(--shadow-soft);
      padding: 18px 18px 20px;
      backdrop-filter: blur(24px);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(56, 189, 248, 0.07), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
      z-index: -1;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.02em;
      background: linear-gradient(120deg, #e5e7eb, #c4b5fd, #38bdf8);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 600;
    }

    .subtitle {
      margin: 4px 0 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      padding: 4px 10px;
      border-radius: var(--radius-full);
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text-muted);
      margin-top: 8px;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2);
    }

    .sidebar-title {
      font-size: 14px;
      font-weight: 500;
      margin: 0 0 8px;
    }

    .sidebar-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 400px;
      overflow: auto;
      font-size: 13px;
    }

    .pdf-item {
      padding: 8px 9px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      cursor: pointer;
      border: 1px solid transparent;
      margin-bottom: 6px;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
    }

    .pdf-item:hover {
      background: rgba(15, 23, 42, 0.9);
      border-color: rgba(55, 65, 81, 0.8);
      transform: translateY(-1px);
    }

    .pdf-item.selected {
      background: rgba(15, 23, 42, 0.98);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.6);
    }

    .pdf-name {
      font-size: 13px;
    }

    .pdf-meta {
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      gap: 6px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-size: 10px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(55, 65, 81, 0.9);
      color: var(--text-main);
      text-transform: lowercase;
      letter-spacing: 0.03em;
    }

    .tag::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      margin-right: 5px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.18);
    }

    .tag.pending::before {
      background: #eab308;
      box-shadow: 0 0 0 4px rgba(234, 179, 8, 0.18);
    }

    .tag.error::before {
      background: #ef4444;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.18);
    }

    .status-text {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }

    .chat-meta {
      font-size: 12px;
      color: var(--text-muted);
    }

    .chat-meta span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-right: 10px;
    }

    .chat-meta-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.7);
    }

    .question-area {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    textarea {
      width: 100%;
      min-height: 80px;
      max-height: 160px;
      resize: vertical;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }

    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45);
    }

    .actions-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 2px;
    }

    button {
      padding: 7px 16px;
      border-radius: var(--radius-full);
      border: 1px solid var(--accent);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-main);
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
    }

    button:hover:not(:disabled) {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 8px 24px rgba(56, 189, 248, 0.25);
      border-color: #7dd3fc;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }

    .status-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .results-box {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.95);
      font-size: 13px;
      max-height: none;
      overflow: visible;
      transition: all 0.3s ease-in-out;
      min-height: 0;
    }

    /* Contenedor interno para scroll cuando sea necesario */
    .answer-content-wrapper {
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 4px;
      scroll-behavior: smooth;
    }

    .answer-content-wrapper::-webkit-scrollbar {
      width: 8px;
    }

    .answer-content-wrapper::-webkit-scrollbar-track {
      background: rgba(15, 23, 42, 0.5);
      border-radius: 4px;
    }

    .answer-content-wrapper::-webkit-scrollbar-thumb {
      background: rgba(56, 189, 248, 0.4);
      border-radius: 4px;
    }

    .answer-content-wrapper::-webkit-scrollbar-thumb:hover {
      background: rgba(56, 189, 248, 0.6);
    }

    .answer-title {
      font-size: 12px;
      color: var(--text-muted);
      margin: 0 0 4px;
    }

    .answer-text {
      line-height: 1.7;
      font-size: 14px;
      color: var(--text-main);
      margin-bottom: 8px;
    }

    /* Estilos para contenido formateado dentro de la respuesta */
    .answer-text h1,
    .answer-text h2,
    .answer-text h3 {
      color: var(--text-main);
      font-weight: 600;
      margin-top: 20px;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .answer-text h1 {
      font-size: 22px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      padding-bottom: 8px;
      margin-top: 0;
    }

    .answer-text h2 {
      font-size: 18px;
      color: var(--accent);
      margin-top: 24px;
    }

    .answer-text h3 {
      font-size: 16px;
      margin-top: 18px;
      color: var(--text-main);
    }

    .answer-text h1:first-child,
    .answer-text h2:first-child,
    .answer-text h3:first-child {
      margin-top: 0;
    }

    .answer-text p {
      margin: 10px 0;
      line-height: 1.8;
    }

    .answer-text ul,
    .answer-text ol {
      margin: 12px 0;
      padding-left: 28px;
      line-height: 1.9;
    }

    .answer-text li {
      margin: 8px 0;
      padding-left: 4px;
    }

    .answer-text ul li {
      list-style-type: disc;
    }

    .answer-text ol li {
      list-style-type: decimal;
    }

    .answer-text strong {
      color: var(--text-main);
      font-weight: 600;
    }

    .answer-text code {
      background: rgba(15, 23, 42, 0.8);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: var(--accent);
    }

    .context-title {
      font-size: 12px;
      color: var(--text-muted);
      margin: 4px 0 2px;
    }

    .context-list {
      list-style: none;
      padding-left: 0;
      margin: 0;
      font-size: 12px;
      color: var(--text-muted);
    }

    .context-list li {
      margin-bottom: 4px;
    }

    .context-list code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
    }

    /* Estilos para tablas estructuradas */
    .structured-data-container {
      margin-top: 20px;
      margin-bottom: 16px;
    }

    .structured-table-wrapper {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      max-height: 500px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px;
      margin-top: 12px;
      background: rgba(15, 23, 42, 0.5);
    }

    .structured-table {
      width: 100%;
      min-width: 600px;
      border-collapse: collapse;
      font-size: 13px;
    }

    .structured-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(15, 23, 42, 0.95);
    }

    .structured-table th {
      padding: 10px 12px;
      text-align: left;
      font-weight: 600;
      color: var(--accent);
      border-bottom: 2px solid rgba(56, 189, 248, 0.3);
      background: rgba(15, 23, 42, 0.95);
    }

    .structured-table td {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      color: var(--text-main);
    }

    .structured-table tbody tr:hover {
      background: rgba(56, 189, 248, 0.05);
    }

    .structured-table tbody tr:last-child td {
      border-bottom: none;
    }

    .table-info {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(56, 189, 248, 0.1);
      border-radius: 6px;
    }

    .segment-status-message {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
      min-height: 20px;
      transition: all 0.3s ease;
    }

    .segment-status-message:empty {
      display: none;
    }

    /* Modal para subir imagen de segmento */
    .segment-image-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1500;
    }

    .segment-image-modal-content {
      background: var(--card-bg);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 16px 18px;
      width: 100%;
      max-width: 420px;
      box-shadow: var(--shadow-soft);
    }

    .segment-image-modal-title {
      font-size: 14px;
      font-weight: 500;
      margin: 0 0 8px;
    }

    .segment-image-modal-description {
      font-size: 12px;
      color: var(--text-muted);
      margin: 0 0 10px;
    }

    .segment-image-input {
      margin-top: 8px;
      font-size: 12px;
      width: 100%;
    }

    .segment-image-preview {
      margin-top: 10px;
      max-width: 100%;
      border-radius: 12px;
      display: none;
    }

    .segment-image-actions {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .segment-image-status {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Modal para validaci√≥n de campa√±a */
    .campaign-validation-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      padding: 20px;
    }

    .campaign-validation-modal-content {
      background: var(--card-bg);
      border-radius: 16px;
      border: 1px solid rgba(239, 68, 68, 0.3);
      padding: 20px 24px;
      width: 100%;
      max-width: 420px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
    }

    .campaign-validation-modal-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 12px;
      color: #fca5a5;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .campaign-validation-modal-description {
      font-size: 13px;
      color: var(--text-muted);
      margin: 0 0 16px;
      line-height: 1.5;
    }

    .campaign-validation-list {
      list-style: none;
      padding: 0;
      margin: 0 0 20px;
    }

    .campaign-validation-item {
      padding: 10px 12px;
      background: rgba(239, 68, 68, 0.1);
      border-left: 3px solid #ef4444;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--text-main);
    }

    .campaign-validation-item:last-child {
      margin-bottom: 0;
    }

    .campaign-validation-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .campaign-validation-close-btn {
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-main);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .campaign-validation-close-btn:hover {
      background: rgba(15, 23, 42, 1);
      border-color: rgba(148, 163, 184, 0.5);
    }

    @media (max-width: 768px) {
      .campaign-validation-modal {
        padding: 16px;
      }

      .campaign-validation-modal-content {
        padding: 18px 20px;
        max-width: 100%;
      }

      .campaign-validation-modal-title {
        font-size: 15px;
      }

      .campaign-validation-item {
        font-size: 12px;
        padding: 8px 10px;
      }
    }

    @media (max-width: 640px) {
      .campaign-validation-modal {
        padding: 12px;
      }

      .campaign-validation-modal-content {
        padding: 16px 18px;
      }
    }

    .channel-selector {
      margin-top: 12px;
      position: relative;
      display: inline-block;
    }

    .channel-dropdown-btn {
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.18), rgba(15, 23, 42, 0.98));
      color: var(--text-main);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
    }

    .channel-dropdown-btn:hover {
      border-color: var(--accent);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.26), rgba(15, 23, 42, 1));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35), 0 10px 22px rgba(15, 23, 42, 0.9);
      transform: translateY(-1px);
    }

    .channel-selector.open .channel-dropdown-btn {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.6), 0 14px 28px rgba(15, 23, 42, 0.95);
    }

    .channel-dropdown-caret {
      font-size: 10px;
      color: var(--text-muted);
    }

    .channel-dropdown-menu {
      position: absolute;
      top: 110%;
      left: 0;
      min-width: 180px;
      background: rgba(15, 23, 42, 0.98);
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      padding: 8px 10px;
      z-index: 50;
      display: none;
    }

    .channel-selector.open .channel-dropdown-menu {
      display: block;
    }

    .channel-options {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 4px;
    }

    .channel-option {
      width: 100%;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-main);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      text-align: left;
      transition: all 0.15s ease;
    }

    .channel-option:hover {
      border-color: rgba(56, 189, 248, 0.5);
      background: rgba(15, 23, 42, 1);
    }

    .channel-option.selected {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.18);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.5);
    }

    .channel-option-icon {
      font-size: 14px;
    }

    .channel-selected-text {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 4px;
    }

    .export-button {
      margin-top: 16px;
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .export-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(56, 189, 248, 0.4);
    }

    .export-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .export-button:disabled:hover {
      transform: none;
      box-shadow: none;
    }

    /* Sidebar Menu */
    .menu-icon {
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      transition: background 0.2s ease;
      color: var(--accent);
      font-size: 20px;
      background: transparent;
      border: none;
      padding: 0;
    }

    .menu-icon:hover {
      background: rgba(56, 189, 248, 0.1);
    }

    .sidebar-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1500;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      backdrop-filter: blur(4px);
    }

    .sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 280px;
      background: var(--card-bg);
      border-right: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.5);
      z-index: 1501;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      padding: 20px;
      overflow-y: auto;
    }

    .sidebar.active {
      transform: translateX(0);
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
    }

    .sidebar-brand-name {
      background: linear-gradient(120deg, #e5e7eb, #c4b5fd, #38bdf8);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .sidebar-brand-number {
      color: #f59e0b;
      font-weight: 700;
      text-shadow: 0 0 12px rgba(245, 158, 11, 0.6), 0 0 24px rgba(245, 158, 11, 0.4);
    }

    .sidebar-close {
      cursor: pointer;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      color: var(--text-muted);
      transition: background 0.2s ease, color 0.2s ease;
      font-size: 20px;
      background: transparent;
      border: none;
      padding: 0;
    }

    .sidebar-close:hover {
      background: rgba(148, 163, 184, 0.1);
      color: var(--text-main);
    }

    .sidebar-menu {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sidebar-menu-item {
      margin-bottom: 8px;
    }

    .sidebar-menu-link {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-radius: 12px;
      color: var(--text-main);
      text-decoration: none;
      transition: background 0.2s ease, transform 0.1s ease;
      font-size: 14px;
    }

    .sidebar-menu-link:hover {
      background: rgba(56, 189, 248, 0.1);
      transform: translateX(4px);
    }

    .sidebar-menu-link.active {
      background: linear-gradient(90deg, rgba(56, 189, 248, 0.2), rgba(56, 189, 248, 0.1));
      border-radius: 10px;
      transform: translateX(2px);
    }

    .sidebar-menu-icon {
      font-size: 18px;
      width: 24px;
      text-align: center;
    }

    .sidebar-user {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid rgba(148, 163, 184, 0.2);
      font-size: 13px;
      color: var(--text-muted);
    }

    @media (max-width: 640px) {
      .sidebar {
        width: 260px;
      }
    }
  </style>
</head>
<body>
  <div class="bg-aurora">
    <div class="aurora-blob"></div>
    <div class="aurora-blob"></div>
    <div class="aurora-blob"></div>
  </div>

  <!-- Navbar -->
  <nav style="position: fixed; top: 0; left: 0; right: 0; z-index: 1000; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(148, 163, 184, 0.2); padding: 10px 16px;">
    <div style="max-width: 1024px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap;">
      <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
        <button id="menuToggle" class="menu-icon" aria-label="Abrir men√∫">
          ‚ò∞
        </button>
        <span style="color: var(--text-muted);">|</span>
        <span id="navUserName" style="color: var(--text-main); font-size: 0.85rem;"></span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
        <button id="logoutBtn" style="padding: 6px 10px; border-radius: 8px; border: 1px solid var(--accent); background: transparent; color: var(--accent); cursor: pointer; font-size: 0.85rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(56, 189, 248, 0.1)'" onmouseout="this.style.background='transparent'">Cerrar Sesi√≥n</button>
      </div>
    </div>
  </nav>

  <!-- Sidebar Overlay -->
  <div id="sidebarOverlay" class="sidebar-overlay"></div>

  <!-- Sidebar -->
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title"><span class="sidebar-brand-name">Marketing</span> <span class="sidebar-brand-number">360</span></div>
      <button id="sidebarClose" class="sidebar-close" aria-label="Cerrar men√∫">√ó</button>
    </div>
    <ul class="sidebar-menu">
      <li class="sidebar-menu-item">
        <a href="/pdfs.html" class="sidebar-menu-link">
          <span class="sidebar-menu-icon">üìÑ</span>
          <span>Subir documentos</span>
        </a>
      </li>
      <li class="sidebar-menu-item">
        <a href="/rag.html" class="sidebar-menu-link">
          <span class="sidebar-menu-icon">üí¨</span>
          <span>Mi chat</span>
        </a>
      </li>
      <li class="sidebar-menu-item">
        <a href="/metrics.html" class="sidebar-menu-link">
          <span class="sidebar-menu-icon">üìä</span>
          <span>M√©tricas del sistema</span>
        </a>
      </li>
    </ul>
    <div class="sidebar-user">
      Usuario: <span id="sidebarUserName"></span>
    </div>
  </aside>

  <div class="page-shell" style="margin-top: 60px;">
    <div class="card" style="margin-bottom: 14px;">
      <h1>Chat con tus DOCs</h1>
      <p class="subtitle">
        Elige un DOC procesado y hazle preguntas sobre tus clientes
      </p>
      <div class="pill">
        <span class="pill-dot"></span>
        Primero sube/procesa/embebe los PDFs en <code>pdfs.html</code>, luego chatea aqu√≠.
      </div>
    </div>

    <div class="layout">
      <!-- Lateral: lista de PDFs -->
      <div class="card">
        <p class="sidebar-title">DOCs disponibles</p>
        <p class="status-text" id="pdf-list-status">Cargando lista de PDFs...</p>
        <ul id="pdf-list" class="sidebar-list"></ul>
      </div>

      <!-- Panel de chat RAG -->
      <div class="card">
        <div class="chat-header">
          <div>
            <p class="sidebar-title">Preguntas al DOC seleccionado</p>
            <p class="chat-meta" id="chat-meta">
              <span><span class="chat-meta-dot"></span> Esperando selecci√≥n de PDF</span>
            </p>
          </div>
        </div>

        <div class="question-area">
          <textarea
            id="question-input"
            placeholder="Ejemplo: ¬øCu√°l es el objetivo principal de este documento?"
          ></textarea>
          <div class="actions-row">
            <span class="status-label" id="rag-status"></span>
            <button id="ask-btn" type="button">
              <span>Preguntar al DOC</span>
            </button>
          </div>
        </div>

        <div id="results" class="results-box" style="display: none;">
          <p class="answer-title">Respuesta:</p>
          <div class="answer-content-wrapper">
            <div id="answer-text" class="answer-text"></div>
          </div>
          <p class="context-title" style="display: none;">Fragmentos usados como contexto:</p>
          <ul id="context-list" class="context-list" style="display: none;"></ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Script de autenticaci√≥n -->
  <script type="module">
    import { checkAuth, getUser, logout, fetchWithAuth } from '/js/auth.js';

    // Verificar autenticaci√≥n al cargar
    if (!checkAuth()) {
      // Redirigir√° autom√°ticamente a login
    } else {
      // Mostrar nombre de usuario en navbar
      const user = getUser();
      if (user) {
        document.getElementById('navUserName').textContent = user.name || user.email;
      }
    }

    // Configurar event listener para logout cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', () => {
      const logoutButton = document.getElementById('logoutBtn');
      if (logoutButton) {
        logoutButton.addEventListener('click', (e) => {
          e.preventDefault();
          logout();
        });
      }
    });

    // Exportar fetchWithAuth para usar en el c√≥digo inline
    window.fetchWithAuth = fetchWithAuth;
  </script>

  <script>
    let pdfList = [];
    let selectedPdfId = null;
    let currentSegmentCandidate = null; // Segmento sugerido por RAG (clientes con nombres repetidos)

    const RAG_CACHE_KEY = 'rag_last_response_v1';

    function saveLastRagResponse(pdfId, question, responseData) {
      try {
        const payload = {
          pdfId,
          question,
          responseData,
          savedAt: new Date().toISOString(),
        };
        localStorage.setItem(RAG_CACHE_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn('No se pudo guardar cache RAG:', e);
      }
    }

    function loadLastRagResponse() {
      try {
        const raw = localStorage.getItem(RAG_CACHE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) {
        console.warn('No se pudo leer cache RAG:', e);
        return null;
      }
    }

    function clearLastRagResponse() {
      try {
        localStorage.removeItem(RAG_CACHE_KEY);
      } catch (e) {
        console.warn('No se pudo limpiar cache RAG:', e);
      }
    }

    function updateChannelsInCache(channels) {
      try {
        const cached = loadLastRagResponse();
        if (!cached || !cached.responseData || !cached.responseData.segmentCandidate) {
          return;
        }
        // Solo actualizar si corresponde al PDF seleccionado actualmente
        if (cached.pdfId !== selectedPdfId) {
          return;
        }
        cached.responseData.segmentCandidate.canalesOrigen = channels;
        saveLastRagResponse(cached.pdfId, cached.question, cached.responseData);
      } catch (e) {
        console.warn('No se pudo actualizar canales en cache RAG:', e);
      }
    }

    function updateSegmentImageInCache(imageUrlPromo) {
      try {
        const cached = loadLastRagResponse();
        if (!cached || !cached.responseData || !cached.responseData.segmentCandidate) {
          return;
        }
        if (cached.pdfId !== selectedPdfId) {
          return;
        }
        const seg = cached.responseData.segmentCandidate;
        seg.imageUrlPromo = imageUrlPromo;
        // Mantener tambi√©n un array de im√°genes
        let arr = Array.isArray(seg.imageUrlsPromo) ? seg.imageUrlsPromo : [];
        if (!arr.includes(imageUrlPromo)) {
          arr = [...arr, imageUrlPromo];
        }
        seg.imageUrlsPromo = arr;
        saveLastRagResponse(cached.pdfId, cached.question, cached.responseData);
      } catch (e) {
        console.warn('No se pudo actualizar imagen en cache RAG:', e);
      }
    }

    async function loadPdfs() {
      const statusEl = document.getElementById("pdf-list-status");
      const listEl = document.getElementById("pdf-list");
      statusEl.textContent = "Cargando lista de PDFs...";
      listEl.innerHTML = "";

      try {
        const res = await fetchWithAuth("/api/pdf");
        const data = await res.json();

        if (!res.ok || !data.ok) {
          throw new Error(data.message || "Error al obtener la lista de PDFs.");
        }

        pdfList = Array.isArray(data.data?.pdfs) ? data.data.pdfs : [];

        if (!pdfList.length) {
          statusEl.textContent = "No hay PDFs subidos a√∫n.";
          return;
        }

        // Filtramos por PDFs procesados y embebidos (processed o ready)
        const processed = pdfList.filter((pdf) => 
          pdf.status === "processed" || pdf.status === "ready"
        );
        if (!processed.length) {
          statusEl.textContent =
            "No hay PDFs procesados y embebidos. Ve a pdfs.html, proc√©salos y env√≠alos a Qdrant primero.";
          return;
        }

        statusEl.textContent = "Selecciona un DOC para empezar a preguntar.";
        listEl.innerHTML = "";

        processed.forEach((pdf) => {
          const li = document.createElement("li");
          li.className = "pdf-item";
          li.dataset.id = pdf._id;

          const sizeKb = pdf.size ? (pdf.size / 1024).toFixed(1) + " KB" : "";
          const createdAt = pdf.createdAt
            ? new Date(pdf.createdAt).toLocaleString()
            : "-";

          const tagClass = (pdf.status === "processed" || pdf.status === "ready") ? "" : " pending";

          li.innerHTML = `
            <div class="pdf-name">${pdf.originalName || pdf.fileName || pdf._id}</div>
            <div class="pdf-meta">
              <span>${sizeKb}</span>
              <span>${createdAt}</span>
            </div>
            <div class="pdf-meta">
              <span class="tag${tagClass}">${pdf.status || "uploaded"}</span>
              <span style="margin-left:auto; font-size:11px; color:var(--text-muted);">ID corto: ${String(
                pdf._id
              ).slice(0, 6)}...</span>
            </div>
          `;

          li.addEventListener("click", () => handleSelectPdf(pdf._id));
          listEl.appendChild(li);
        });

        // Seleccionar por defecto el primero
        if (!selectedPdfId && processed.length > 0) {
          handleSelectPdf(processed[0]._id);
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error al cargar la lista de PDFs: " + err.message;
      }
    }

    function handleSelectPdf(pdfId) {
      selectedPdfId = pdfId;

      const listEl = document.getElementById("pdf-list");
      const items = listEl.querySelectorAll(".pdf-item");
      items.forEach((item) => {
        if (item.dataset.id === pdfId) {
          item.classList.add("selected");
        } else {
          item.classList.remove("selected");
        }
      });

      const pdf = pdfList.find((p) => p._id === pdfId);
      const metaEl = document.getElementById("chat-meta");
      if (pdf) {
        metaEl.innerHTML = `
          <span><span class="chat-meta-dot"></span> Preguntando a: <strong>${
            pdf.originalName || pdf.fileName || pdf._id
          }</strong></span>
          <span>Estado: <code>${pdf.status || "uploaded"}</code></span>
        `;
      } else {
        metaEl.innerHTML =
          '<span><span class="chat-meta-dot"></span> Esperando selecci√≥n de PDF</span>';
      }

      // üîÑ Limpiar el √°rea de pregunta y respuestas al seleccionar un documento
      const questionInput = document.getElementById("question-input");
      const resultsBox = document.getElementById("results");
      const answerEl = document.getElementById("answer-text");
      const statusEl = document.getElementById("rag-status");

      // Limpiar el textarea de pregunta
      if (questionInput) {
        questionInput.value = "";
      }

      // Ocultar y limpiar el √°rea de resultados
      if (resultsBox) {
        resultsBox.style.display = "none";
      }
      if (answerEl) {
        answerEl.innerHTML = "";
      }

      // Limpiar el mensaje de estado
      if (statusEl) {
        statusEl.textContent = "";
      }

      // Intentar restaurar √∫ltima respuesta RAG para este PDF desde cache
      const cached = loadLastRagResponse();
      if (cached && cached.pdfId === pdfId && cached.responseData) {
        const statusCachedEl = document.getElementById("rag-status");
        if (statusCachedEl) {
          statusCachedEl.textContent = `Mostrando √∫ltima respuesta guardada para este PDF (pregunta: "${cached.question}")`;
        }
        renderRagResponseFromData(cached.responseData);
      }
    }

    // Funci√≥n para convertir Markdown b√°sico a HTML
    function formatMarkdownToHtml(text) {
      if (!text) return "";
      
      // Escapar HTML b√°sico primero para seguridad
      const escapeHtml = (str) => {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      };
      
      let html = escapeHtml(text);
      
      // Convertir negritas (**texto** -> <strong>texto</strong>)
      html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // Dividir en l√≠neas para procesar
      const lines = html.split('\n');
      const output = [];
      let currentList = null;
      let currentListType = null;
      
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        if (!line) {
          if (currentList) {
            output.push(`</${currentListType}>`);
            currentList = null;
            currentListType = null;
          }
          continue;
        }
        
        // Detectar t√≠tulos
        if (line.match(/^###\s+(.+)$/)) {
          if (currentList) {
            output.push(`</${currentListType}>`);
            currentList = null;
            currentListType = null;
          }
          output.push(`<h3>${line.replace(/^###\s+/, '').trim()}</h3>`);
          continue;
        }
        
        if (line.match(/^##\s+(.+)$/)) {
          if (currentList) {
            output.push(`</${currentListType}>`);
            currentList = null;
            currentListType = null;
          }
          output.push(`<h2>${line.replace(/^##\s+/, '').trim()}</h2>`);
          continue;
        }
        
        if (line.match(/^#\s+(.+)$/)) {
          if (currentList) {
            output.push(`</${currentListType}>`);
            currentList = null;
            currentListType = null;
          }
          output.push(`<h1>${line.replace(/^#\s+/, '').trim()}</h1>`);
          continue;
        }
        
        // Detectar listas numeradas (1. texto o 10. texto)
        const numberedMatch = line.match(/^(\d+)\.\s+(.+)$/);
        if (numberedMatch) {
          if (currentListType !== 'ol') {
            if (currentList) {
              output.push(`</${currentListType}>`);
            }
            output.push('<ol>');
            currentList = true;
            currentListType = 'ol';
          }
          output.push(`<li>${numberedMatch[2].trim()}</li>`);
          continue;
        }
        
        // Detectar listas con guiones (- texto)
        const bulletMatch = line.match(/^-\s+(.+)$/);
        if (bulletMatch) {
          if (currentListType !== 'ul') {
            if (currentList) {
              output.push(`</${currentListType}>`);
            }
            output.push('<ul>');
            currentList = true;
            currentListType = 'ul';
          }
          output.push(`<li>${bulletMatch[1].trim()}</li>`);
          continue;
        }
        
        // Si llegamos aqu√≠, es texto normal
        if (currentList) {
          output.push(`</${currentListType}>`);
          currentList = null;
          currentListType = null;
        }
        
        // Convertir a p√°rrafo si no est√° vac√≠o
        if (line) {
          output.push(`<p>${line}</p>`);
        }
      }
      
      // Cerrar lista abierta si existe
      if (currentList) {
        output.push(`</${currentListType}>`);
      }
      
      html = output.join('\n');
      
      // Limpiar p√°rrafos vac√≠os
      html = html.replace(/<p>\s*<\/p>/g, '');
      
      return html;
    }

    /**
     * Escapa caracteres HTML especiales para prevenir inyecci√≥n y romper estructura
     * @param {string} str - Cadena a escapar
     * @returns {string} Cadena escapada
     */
    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      const text = String(str);
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, m => map[m]);
    }

    /**
     * Limpia un valor, detectando y removiendo datos concatenados con pipes
     * @param {string} value - Valor a limpiar
     * @returns {string} Valor limpio
     */
    function cleanValue(value) {
      if (value === null || value === undefined) return '';
      let cleaned = String(value).trim();
      
      // Si el valor contiene pipes, probablemente es un error de parsing
      // Tomar solo la primera parte antes del primer pipe adicional
      if (cleaned.includes('|')) {
        const parts = cleaned.split('|').map(p => p.trim()).filter(p => p);
        // Si hay m√∫ltiples partes separadas por pipes, tomar solo la primera
        if (parts.length > 1) {
          cleaned = parts[0];
        } else {
          // Si solo hay una parte pero contiene el pipe, removerlo
          cleaned = cleaned.replace(/\|/g, '').trim();
        }
      }
      
      return cleaned;
    }

    /**
     * Renderiza datos estructurados como tabla HTML
     * @param {Array<Object>} structuredData - Array de objetos con datos estructurados
     * @param {number} totalRows - Total de filas encontradas
     * @returns {string} HTML de la tabla
     */
    function renderStructuredData(structuredData, totalRows) {
      if (!structuredData || !Array.isArray(structuredData) || structuredData.length === 0) {
        return '';
      }

      // Detectar todas las columnas posibles desde las keys de todos los objetos
      const allColumns = new Set();
      structuredData.forEach(row => {
        if (row && typeof row === 'object') {
          Object.keys(row).forEach(key => allColumns.add(key));
        }
      });

      // Orden preferente de columnas
      const preferredOrder = ['name', 'email', 'vehicle', 'phone'];
      
      // Construir orden de columnas: primero las preferidas, luego el resto
      let columns = [];
      const remainingColumns = [];
      
      // Agregar columnas en orden preferente si existen
      preferredOrder.forEach(col => {
        if (allColumns.has(col)) {
          columns.push(col);
        }
      });
      
      // Agregar columnas adicionales que no est√©n en el orden preferente
      allColumns.forEach(col => {
        if (!preferredOrder.includes(col) && !columns.includes(col)) {
          remainingColumns.push(col);
        }
      });
      
      // Ordenar columnas restantes alfab√©ticamente y agregarlas
      columns = [...columns, ...remainingColumns.sort()];
      
      // Fallback: si no hay columnas, usar orden alfab√©tico de todas
      if (columns.length === 0) {
        columns = Array.from(allColumns).sort();
      }

      if (columns.length === 0) {
        return '';
      }

      // Construir HTML de la tabla
      let tableHTML = '<div class="structured-data-container">';
      tableHTML += '<div class="structured-table-wrapper">';
      tableHTML += '<table class="structured-table">';
      
      // Encabezados
      tableHTML += '<thead><tr>';
      columns.forEach(col => {
        const headerText = col.charAt(0).toUpperCase() + col.slice(1);
        tableHTML += `<th>${headerText}</th>`;
      });
      tableHTML += '</tr></thead>';

      // Filas de datos
      tableHTML += '<tbody>';
      structuredData.forEach(row => {
        tableHTML += '<tr>';
        columns.forEach(col => {
          const rawValue = row[col] !== null && row[col] !== undefined ? String(row[col]) : '';
          // Limpiar el valor antes de escapar
          const cleanedValue = cleanValue(rawValue);
          // Escapar caracteres HTML para prevenir inyecci√≥n y romper estructura
          const escapedValue = escapeHtml(cleanedValue);
          tableHTML += `<td>${escapedValue}</td>`;
        });
        tableHTML += '</tr>';
      });
      tableHTML += '</tbody>';

      tableHTML += '</table>';
      tableHTML += '</div>';

      // Mensaje informativo si hay m√°s filas
      if (totalRows > structuredData.length) {
        tableHTML += `<div class="table-info">`;
        tableHTML += `En la tabla se muestran las primeras ${structuredData.length} filas de ${totalRows} totales. `;
        tableHTML += `El archivo Excel contiene todos los registros.`;
        tableHTML += `</div>`;
      }

      tableHTML += '</div>';

      return tableHTML;
    }

    /**
     * Descarga archivo Excel desde el servidor
     * @param {string} exportId - ID del export a descargar
     */
    async function downloadExcel(exportId) {
      if (!exportId) {
        console.error('Export ID no proporcionado');
        return;
      }

      const exportBtn = document.getElementById('export-excel-btn');
      if (exportBtn) {
        exportBtn.disabled = true;
        exportBtn.textContent = 'Generando Excel...';
      }

      try {
        const token = localStorage.getItem('rag_auth_token');
        if (!token) {
          throw new Error('No hay token de autenticaci√≥n');
        }

        const res = await fetch(`/api/rag/export/${exportId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        });

        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ message: 'Error al descargar Excel' }));
          throw new Error(errorData.message || 'Error al descargar Excel');
        }

        // Obtener nombre de archivo desde headers o generar uno
        const contentDisposition = res.headers.get('Content-Disposition');
        let filename = `export-${Date.now()}.xlsx`;
        if (contentDisposition) {
          const filenameMatch = contentDisposition.match(/filename="(.+)"/);
          if (filenameMatch) {
            filename = filenameMatch[1];
          }
        }

        // Crear blob y descargar
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);

        console.log(`Excel descargado: ${filename}`);
      } catch (error) {
        console.error('Error al descargar Excel:', error);
        alert(`Error al descargar Excel: ${error.message}`);
      } finally {
        if (exportBtn) {
          exportBtn.disabled = false;
          exportBtn.innerHTML = 'üì• Descargar Excel';
        }
      }
    }

    /**
     * Sube imagen de segmento a trav√©s del backend (Cloudinary)
     * @param {File} file - Archivo de imagen seleccionado
     * @returns {Promise<string>} URL segura de la imagen en Cloudinary
     */
    async function uploadSegmentImage(file) {
      if (!file) {
        throw new Error("No se seleccion√≥ ninguna imagen.");
      }

      const MAX_IMAGE_SIZE_BYTES = 5 * 1024 * 1024; // 5 MB
      if (file.size > MAX_IMAGE_SIZE_BYTES) {
        throw new Error("La imagen excede el tama√±o m√°ximo permitido de 5MB.");
      }

      const token = localStorage.getItem('rag_auth_token');
      if (!token) {
        throw new Error("No hay token de autenticaci√≥n.");
      }

      const formData = new FormData();
      formData.append("image", file);

      const res = await fetch("/api/segments/upload-image", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: formData,
      });

      const data = await res.json().catch(() => ({
        ok: false,
        message: "Error al subir imagen (respuesta inv√°lida del servidor).",
      }));

      if (!res.ok || !data.ok) {
        throw new Error(data.message || "Error al subir imagen para segmento.");
      }

      const imageUrl = data.data?.imageUrl;
      if (!imageUrl) {
        throw new Error("El servidor no devolvi√≥ la URL de la imagen.");
      }

      return imageUrl;
    }

    /**
     * Renderiza en la UI una respuesta RAG ya obtenida (sin llamar al backend)
     * @param {Object} responseData - data.data de /api/rag/query
     */
    function renderRagResponseFromData(responseData) {
      const resultsBox = document.getElementById("results");
      const answerEl = document.getElementById("answer-text");
      if (!resultsBox || !answerEl) return;

      let fullAnswerHTML = formatMarkdownToHtml(responseData?.answer || "(sin respuesta)");

      if (responseData?.structuredData && Array.isArray(responseData.structuredData) && responseData.structuredData.length > 0) {
        const totalRows = responseData.totalRows || responseData.structuredData.length;
        const tableHTML = renderStructuredData(responseData.structuredData, totalRows);
        fullAnswerHTML += tableHTML;

        if (responseData.exportId) {
          const exportId = responseData.exportId;
          fullAnswerHTML += `<button id="export-excel-btn" class="export-button" data-export-id="${exportId}">üì• Descargar Excel</button>`;
        }
      }

      // Actualizar candidato de segmento si existe
      currentSegmentCandidate = responseData.segmentCandidate || null;

      // Solo mostrar botones si hay clientes en el segmentCandidate
      const hasClients = currentSegmentCandidate && 
                        Array.isArray(currentSegmentCandidate.clientes) && 
                        currentSegmentCandidate.clientes.length > 0;

      if (currentSegmentCandidate && hasClients) {
        // Normalizar array de im√°genes: si viene solo imageUrlPromo, crear un array con esa primera imagen
        if (!Array.isArray(currentSegmentCandidate.imageUrlsPromo)) {
          const firstImage = currentSegmentCandidate.imageUrlPromo && currentSegmentCandidate.imageUrlPromo.trim()
            ? [currentSegmentCandidate.imageUrlPromo]
            : [];
          currentSegmentCandidate.imageUrlsPromo = firstImage;
        }

        // Normalizar canales de origen a etiquetas de UI ('Email', 'WhatsApp')
        const rawChannels = Array.isArray(currentSegmentCandidate.canalesOrigen)
          ? currentSegmentCandidate.canalesOrigen
          : [];
        const mapLabel = (value) => {
          const normalized = (value || '').toString().toLowerCase();
          if (normalized === 'email' || normalized === 'emails' || normalized === 'correo') return 'Email';
          if (normalized === 'whatsapp' || normalized === 'wasap' || normalized === 'ws') return 'WhatsApp';
          return value;
        };
        let uiChannels = rawChannels.map(mapLabel).filter(Boolean);
        // Si no hay nada, default a Email
        if (uiChannels.length === 0) {
          uiChannels = ['Email'];
        }
        // Eliminar duplicados
        uiChannels = Array.from(new Set(uiChannels));
        currentSegmentCandidate.canalesOrigen = uiChannels;

        fullAnswerHTML += `
          <div class="channel-selector">
            <button type="button" id="channel-dropdown-btn" class="channel-dropdown-btn">
              <span>Canales</span>
              <span class="channel-dropdown-caret">‚ñæ</span>
            </button>
            <div class="channel-dropdown-menu">
              <div class="channel-options">
                <button type="button" class="channel-option" data-channel="Email">
                  <span class="channel-option-icon">üìß</span>
                  <span>Email</span>
                </button>
                <button type="button" class="channel-option" data-channel="WhatsApp">
                  <span class="channel-option-icon">üí¨</span>
                  <span>WhatsApp</span>
                </button>
              </div>
              <div id="channel-selected-text" class="channel-selected-text"></div>
            </div>
          </div>
          <button id="upload-segment-image-btn" class="export-button" style="margin-left: 8px; background: rgba(15,23,42,0.95); border-color: var(--accent-2);">
            üñºÔ∏è Subir imagen
          </button>
          <button id="create-segment-btn" class="export-button" style="margin-left: 8px;">
            ‚ûï Crear segmento
          </button>
          <button id="create-campaign-btn" class="export-button" style="margin-left: 8px; background: linear-gradient(135deg, var(--accent-2), var(--accent));">
            üöÄ Crear campa√±a
          </button>
          <div id="segment-status" class="segment-status-message"></div>
          <div id="segment-image-modal" class="segment-image-modal">
            <div class="segment-image-modal-content">
              <h3 class="segment-image-modal-title">Subir imagen para el segmento</h3>
              <p class="segment-image-modal-description">
                Sube una imagen promocional (m√°x. 5MB) que se asociar√° a este segmento.
              </p>
              <input id="segment-image-input" class="segment-image-input" type="file" multiple accept="image/png,image/jpeg,image/jpg,image/gif,image/webp" />
              <img id="segment-image-preview" class="segment-image-preview" alt="Preview imagen segmento" />
              <div class="segment-image-actions">
                <button type="button" id="segment-image-cancel-btn">
                  Cancelar
                </button>
                <button type="button" id="segment-image-upload-btn">
                  Subir a Cloudinary
                </button>
              </div>
              <div id="segment-image-status" class="segment-image-status"></div>
            </div>
          </div>
          <!-- Modal de validaci√≥n de campa√±a -->
          <div id="campaign-validation-modal" class="campaign-validation-modal">
            <div class="campaign-validation-modal-content">
              <h3 class="campaign-validation-modal-title">
                <span>‚ö†Ô∏è</span>
                <span>Faltan datos para crear la campa√±a</span>
              </h3>
              <p class="campaign-validation-modal-description">
                Para crear una campa√±a, necesitas completar los siguientes campos:
              </p>
              <ul id="campaign-validation-list" class="campaign-validation-list"></ul>
              <div class="campaign-validation-actions">
                <button type="button" id="campaign-validation-close-btn" class="campaign-validation-close-btn">
                  Entendido
                </button>
              </div>
            </div>
          </div>
        `;
      }

      resultsBox.style.display = "block";
      answerEl.innerHTML = fullAnswerHTML;

      const exportBtn = document.getElementById('export-excel-btn');
      if (exportBtn) {
        const exportId = exportBtn.getAttribute('data-export-id');
        exportBtn.addEventListener('click', () => downloadExcel(exportId));
      }

      // Configurar selector de canales si hay candidato de segmento
      if (currentSegmentCandidate) {
        const channelSelectorEl = document.querySelector('.channel-selector');
        const dropdownBtn = document.getElementById('channel-dropdown-btn');
        const dropdownMenu = channelSelectorEl ? channelSelectorEl.querySelector('.channel-dropdown-menu') : null;
        const channelButtons = Array.from(document.querySelectorAll('.channel-option'));
        const channelSelectedTextEl = document.getElementById('channel-selected-text');

        // Usar copia local del array para manejar UI
        let channels = Array.isArray(currentSegmentCandidate.canalesOrigen)
          ? [...currentSegmentCandidate.canalesOrigen]
          : [];

        const normalize = (label) => (label || '').toString().toLowerCase();

        const updateChannelUI = () => {
          const setNorm = new Set(channels.map(normalize));
          channelButtons.forEach((btn) => {
            const label = btn.getAttribute('data-channel');
            if (setNorm.has(normalize(label))) {
              btn.classList.add('selected');
            } else {
              btn.classList.remove('selected');
            }
          });
          if (channelSelectedTextEl) {
            if (!channels.length) {
              channelSelectedTextEl.textContent = 'Canales seleccionados: ninguno';
            } else {
              channelSelectedTextEl.textContent = 'Canales seleccionados: ' + channels.join(', ');
            }
          }
        };

        channelButtons.forEach((btn) => {
          btn.addEventListener('click', (e) => {
            // Evitar que el click en el item cierre inmediatamente el dropdown
            e.stopPropagation();
            const label = btn.getAttribute('data-channel');
            const idx = channels.findIndex((c) => normalize(c) === normalize(label));
            if (idx === -1) {
              channels.push(label);
            } else {
              channels.splice(idx, 1);
            }
            // Actualizar estado global y cache
            channels = Array.from(new Set(channels));
            currentSegmentCandidate.canalesOrigen = channels;
            updateChannelsInCache(channels);
            updateChannelUI();
          });
        });

        if (dropdownBtn && channelSelectorEl && dropdownMenu) {
          dropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            channelSelectorEl.classList.toggle('open');
          });

          // Cerrar el dropdown solo cuando se hace click fuera del selector
          document.addEventListener('click', (event) => {
            if (!channelSelectorEl.contains(event.target)) {
              channelSelectorEl.classList.remove('open');
            }
          });
        }

        // Inicializar UI con el estado actual
        updateChannelUI();
      }

      const createSegmentBtn = document.getElementById('create-segment-btn');
      const createCampaignBtn = document.getElementById('create-campaign-btn');
      const uploadSegmentImageBtn = document.getElementById('upload-segment-image-btn');
      const segmentImageModal = document.getElementById('segment-image-modal');

      if (currentSegmentCandidate && uploadSegmentImageBtn && segmentImageModal) {
        const imageInput = document.getElementById('segment-image-input');
        const imagePreview = document.getElementById('segment-image-preview');
        const imageUploadBtn = document.getElementById('segment-image-upload-btn');
        const imageCancelBtn = document.getElementById('segment-image-cancel-btn');
        const imageStatusEl = document.getElementById('segment-image-status');

        const closeModal = () => {
          segmentImageModal.style.display = 'none';
          if (imageStatusEl) {
            imageStatusEl.textContent = '';
            imageStatusEl.style.color = 'var(--text-muted)';
          }
          if (imageInput) {
            imageInput.value = '';
          }
          if (imagePreview) {
            imagePreview.style.display = 'none';
            imagePreview.src = '';
          }
        };

        uploadSegmentImageBtn.addEventListener('click', () => {
          // Empezar una nueva selecci√≥n de im√°genes para este segmento:
          // solo las que se suban en esta sesi√≥n se enviar√°n al backend.
          currentSegmentCandidate.imageUrlsPromo = [];
          segmentImageModal.style.display = 'flex';
        });

        if (imageCancelBtn) {
          imageCancelBtn.addEventListener('click', () => {
            closeModal();
          });
        }

        if (imageInput && imagePreview) {
          imageInput.addEventListener('change', (event) => {
            const files = event.target.files;
            const file = files && files[0];
            if (!file) {
              imagePreview.style.display = 'none';
              imagePreview.src = '';
              if (imageStatusEl) {
                imageStatusEl.textContent = '';
                imageStatusEl.style.color = 'var(--text-muted)';
              }
              return;
            }

            const MAX_IMAGE_SIZE_BYTES = 5 * 1024 * 1024;
            if (file.size > MAX_IMAGE_SIZE_BYTES) {
              if (imageStatusEl) {
                imageStatusEl.textContent = 'Una de las im√°genes excede el tama√±o m√°ximo permitido de 5MB.';
                imageStatusEl.style.color = '#ef4444';
              }
              imageInput.value = '';
              imagePreview.style.display = 'none';
              imagePreview.src = '';
              return;
            }

            const objectUrl = URL.createObjectURL(file);
            imagePreview.src = objectUrl;
            imagePreview.style.display = 'block';

            if (imageStatusEl) {
              const count = files ? files.length : 1;
              imageStatusEl.textContent = count === 1
                ? '1 imagen seleccionada.'
                : `${count} im√°genes seleccionadas.`;
              imageStatusEl.style.color = 'var(--text-muted)';
            }
          });
        }

        if (imageUploadBtn && imageInput) {
          imageUploadBtn.addEventListener('click', async () => {
            try {
              const files = imageInput.files ? Array.from(imageInput.files) : [];
              if (!files.length) {
                if (imageStatusEl) {
                  imageStatusEl.textContent = 'Primero selecciona al menos una imagen.';
                  imageStatusEl.style.color = '#ef4444';
                }
                return;
              }

              imageUploadBtn.disabled = true;
              imageUploadBtn.textContent = 'Subiendo...';
              if (imageStatusEl) {
                imageStatusEl.textContent = `Subiendo ${files.length} imagen(es)...`;
                imageStatusEl.style.color = 'var(--text-muted)';
              }

              const uploadedUrls = [];

              for (const file of files) {
                const MAX_IMAGE_SIZE_BYTES = 5 * 1024 * 1024;
                if (file.size > MAX_IMAGE_SIZE_BYTES) {
                  throw new Error(`La imagen "${file.name}" excede el tama√±o m√°ximo permitido de 5MB.`);
                }
                const imageUrl = await uploadSegmentImage(file);
                uploadedUrls.push(imageUrl);
                updateSegmentImageInCache(imageUrl);
              }

              // Actualizar el candidato con todas las im√°genes subidas
              if (!Array.isArray(currentSegmentCandidate.imageUrlsPromo)) {
                currentSegmentCandidate.imageUrlsPromo = [];
              }
              uploadedUrls.forEach((url) => {
                if (!currentSegmentCandidate.imageUrlsPromo.includes(url)) {
                  currentSegmentCandidate.imageUrlsPromo.push(url);
                }
              });

              // Mantener imageUrlPromo como imagen principal (primera) si no estaba definida
              if (!currentSegmentCandidate.imageUrlPromo || !currentSegmentCandidate.imageUrlPromo.trim()) {
                currentSegmentCandidate.imageUrlPromo = currentSegmentCandidate.imageUrlsPromo[0] || null;
              }

              if (imageStatusEl) {
                const total = currentSegmentCandidate.imageUrlsPromo.length;
                imageStatusEl.textContent = total === 1
                  ? 'Imagen subida correctamente (1 en total).'
                  : `Im√°genes subidas correctamente (${total} en total).`;
                imageStatusEl.style.color = '#22c55e';
              }

              const segmentStatusEl = document.getElementById('segment-status');
              if (segmentStatusEl) {
                const total = currentSegmentCandidate.imageUrlsPromo.length;
                segmentStatusEl.textContent = total === 1
                  ? '1 imagen promocional asociada al segmento.'
                  : `${total} im√°genes promocionales asociadas al segmento.`;
                segmentStatusEl.style.color = '#22c55e';
              }

              // Habilitar el bot√≥n de crear segmento ahora que hay al menos una imagen
              const createSegmentBtnRef = document.getElementById('create-segment-btn');
              if (createSegmentBtnRef && currentSegmentCandidate.imageUrlsPromo.length > 0) {
                createSegmentBtnRef.disabled = false;
                createSegmentBtnRef.title = '';
              }

              closeModal();
            } catch (error) {
              console.error('Error al subir imagen de segmento:', error);
              if (imageStatusEl) {
                imageStatusEl.textContent = 'Error al subir imagen: ' + error.message;
                imageStatusEl.style.color = '#ef4444';
              }
            } finally {
              imageUploadBtn.disabled = false;
              imageUploadBtn.textContent = 'Subir a Cloudinary';
            }
          });
        }
      }

      // Configurar modal de validaci√≥n de campa√±a (listeners √∫nicos)
      const campaignValidationModal = document.getElementById('campaign-validation-modal');
      const campaignValidationList = document.getElementById('campaign-validation-list');
      const campaignValidationCloseBtn = document.getElementById('campaign-validation-close-btn');

      let lastMissingFields = []; // Guardar para enfoque autom√°tico

      // Funci√≥n helper para validaci√≥n de imagen
      function hasValidImage(segmentCandidate) {
        if (!segmentCandidate) return false;
        
        // Verificar imageUrlPromo (string)
        const imageUrlPromo = segmentCandidate.imageUrlPromo;
        if (imageUrlPromo && typeof imageUrlPromo === 'string' && imageUrlPromo.trim().length > 0) {
          return true;
        }
        
        // Verificar imageUrlsPromo (array)
        const imageUrlsPromo = segmentCandidate.imageUrlsPromo;
        if (Array.isArray(imageUrlsPromo) && imageUrlsPromo.length > 0) {
          // Verificar que al menos un elemento sea una URL v√°lida (no vac√≠a, no null)
          return imageUrlsPromo.some(url => 
            url && typeof url === 'string' && url.trim().length > 0
          );
        }
        
        return false;
      }

      // Funci√≥n para mostrar el modal de validaci√≥n
      function showValidationModal(missingFields) {
        if (!campaignValidationModal || !campaignValidationList) return;
        
        // Guardar campos faltantes para enfoque autom√°tico
        lastMissingFields = missingFields || [];
        
        // Limpiar lista anterior
        campaignValidationList.innerHTML = '';
        
        // Insertar cada campo faltante
        missingFields.forEach(field => {
          const li = document.createElement('li');
          li.className = 'campaign-validation-item';
          li.textContent = field;
          campaignValidationList.appendChild(li);
        });
        
        // Mostrar modal
        campaignValidationModal.style.display = 'flex';
      }

      // Funci√≥n para ocultar el modal y enfocar control relevante
      function hideValidationModal() {
        if (!campaignValidationModal) return;
        
        campaignValidationModal.style.display = 'none';
        
        // Enfoque autom√°tico al control relevante seg√∫n el primer campo faltante
        if (lastMissingFields.length > 0) {
          const firstField = lastMissingFields[0].toLowerCase();
          
          if (firstField.includes('segmento')) {
            // Enfocar bot√≥n "Crear segmento"
            const createSegmentBtn = document.getElementById('create-segment-btn');
            createSegmentBtn?.focus();
          } else if (firstField.includes('canal')) {
            // Enfocar selector de canales
            const channelDropdownBtn = document.getElementById('channel-dropdown-btn');
            channelDropdownBtn?.focus();
          } else if (firstField.includes('imagen')) {
            // Enfocar bot√≥n "Subir imagen"
            const uploadSegmentImageBtn = document.getElementById('upload-segment-image-btn');
            uploadSegmentImageBtn?.focus();
          }
        }
      }

      // Registrar listeners una sola vez
      if (campaignValidationCloseBtn) {
        campaignValidationCloseBtn.addEventListener('click', hideValidationModal);
      }

      if (campaignValidationModal) {
        campaignValidationModal.addEventListener('click', (e) => {
          // Cerrar al hacer click fuera del contenido
          if (e.target === campaignValidationModal) {
            hideValidationModal();
          }
        });
      }

      if (createSegmentBtn && currentSegmentCandidate) {
        const segmentStatusEl = document.getElementById('segment-status');

        // Inicialmente, exigir que exista al menos una imagen antes de permitir crear el segmento
        const hasImage =
          !!(currentSegmentCandidate.imageUrlPromo && currentSegmentCandidate.imageUrlPromo.trim()) ||
          (Array.isArray(currentSegmentCandidate.imageUrlsPromo) &&
            currentSegmentCandidate.imageUrlsPromo.length > 0);
        if (!hasImage) {
          createSegmentBtn.disabled = true;
          createSegmentBtn.title = 'Primero sube una imagen para este segmento.';
        } else {
          createSegmentBtn.disabled = false;
          createSegmentBtn.title = '';
        }

        createSegmentBtn.addEventListener('click', async () => {
          try {
            createSegmentBtn.disabled = true;
            createSegmentBtn.textContent = 'Creando segmento...';

            const payload = {
              sourceDocId: currentSegmentCandidate.sourceDocId,
              descripcionQuery: currentSegmentCandidate.descripcionQuery,
              canalesOrigen: currentSegmentCandidate.canalesOrigen,
              // √öNICO campo con TODAS las im√°genes (array)
              imageUrlPromo: Array.isArray(currentSegmentCandidate.imageUrlsPromo)
                ? currentSegmentCandidate.imageUrlsPromo
                : (currentSegmentCandidate.imageUrlPromo
                    ? [currentSegmentCandidate.imageUrlPromo]
                    : []),
              clientes: currentSegmentCandidate.clientes,
            };

            const resSeg = await fetchWithAuth('/api/segments/create/from-rag', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            const segData = await resSeg.json();
            if (!resSeg.ok || !segData.ok) {
              // Si la API devuelve error (incluyendo falta/formato de imageUrlPromo), mostrarlo
              const message = segData.message || 'Error al crear segmento';
              throw new Error(message);
            }

            if (segmentStatusEl) {
              segmentStatusEl.textContent = 'Segmento creado correctamente. ID: ' + segData.data.segment._id;
              segmentStatusEl.style.color = '#22c55e';
            }
            createSegmentBtn.textContent = 'Segmento creado';

            // Guardar el ID del segmento en el candidato actual para poder iniciar campa√±a
            if (segData.data && segData.data.segment && segData.data.segment._id) {
              currentSegmentCandidate.segmentId = segData.data.segment._id;
              // Habilitar el bot√≥n de campa√±a si existe
              const campaignBtn = document.getElementById('create-campaign-btn');
              if (campaignBtn) {
                campaignBtn.disabled = false;
                campaignBtn.title = '';
              }
            }
          } catch (err) {
            console.error('Error al crear segmento:', err);
            if (segmentStatusEl) {
              segmentStatusEl.textContent = 'Error al crear segmento: ' + err.message;
              segmentStatusEl.style.color = '#ef4444';
            }
            createSegmentBtn.disabled = false;
            createSegmentBtn.textContent = '‚ûï Crear segmento';
          }
        });
      }

      // Bot√≥n para crear/iniciar campa√±a a partir del segmento
      if (createCampaignBtn && currentSegmentCandidate) {
        const segmentStatusEl = document.getElementById('segment-status');
        let isCreatingCampaign = false; // Estado de loading para prevenir doble click

        const hasSegmentId = !!currentSegmentCandidate.segmentId;
        if (!hasSegmentId) {
          createCampaignBtn.disabled = true;
          createCampaignBtn.title = 'Primero crea el segmento para poder iniciar una campa√±a.';
        }

        createCampaignBtn.addEventListener('click', async () => {
          try {
            // A. Validar estado de loading
            if (isCreatingCampaign) {
              return; // Ya est√° en proceso, prevenir doble click
            }

            console.log('[Crear Campa√±a] Current Segment Candidate:', currentSegmentCandidate);
            
            // B. Validar currentSegmentCandidate
            if (!currentSegmentCandidate || currentSegmentCandidate === null || currentSegmentCandidate === undefined) {
              const missingFields = [
                'Segmento: Debes crear el segmento antes de iniciar la campa√±a.',
                'Canal: Debes seleccionar al menos un canal (Email o WhatsApp).',
                'Imagen: Debes subir al menos una imagen promocional para la campa√±a.'
              ];
              showValidationModal(missingFields);
              return;
            }

            // C. Validaci√≥n de campos (en orden: Segmento ‚Üí Canal ‚Üí Imagen)
            const missingFields = [];

            // 1. Validar Segmento
            const segmentId = currentSegmentCandidate.segmentId;
            if (!segmentId) {
              missingFields.push('Segmento: Debes crear el segmento antes de iniciar la campa√±a.');
            }

            // 2. Validar Canal
            const channels = Array.isArray(currentSegmentCandidate.canalesOrigen) 
              ? currentSegmentCandidate.canalesOrigen.filter(ch => ch != null && ch !== '')
              : [];
            if (channels.length === 0) {
              missingFields.push('Canal: Debes seleccionar al menos un canal (Email o WhatsApp).');
            }

            // 3. Validar Imagen (usar funci√≥n helper)
            if (!hasValidImage(currentSegmentCandidate)) {
              missingFields.push('Imagen: Debes subir al menos una imagen promocional para la campa√±a.');
            }

            // D. Si faltan campos, mostrar modal y detener ejecuci√≥n
            if (missingFields.length > 0) {
              showValidationModal(missingFields);
              return;
            }

            // E. Si todos los campos est√°n completos, continuar con creaci√≥n
            isCreatingCampaign = true;
            const originalText = createCampaignBtn.textContent;
            createCampaignBtn.disabled = true;
            createCampaignBtn.textContent = 'Creando campa√±a...';

            console.log('[Crear Campa√±a] Segment ID:', segmentId);

            // Payload m√≠nimo para iniciar campa√±a; ajusta endpoint/estructura seg√∫n tu backend
            const payload = {
              segmentId,
            };
            
            console.log('[Crear Campa√±a] Payload enviado:', JSON.stringify(payload, null, 2));

            const resCamp = await fetchWithAuth('/api/campaigns/start-from-segment', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            console.log('[Crear Campa√±a] Response status:', resCamp.status);
            console.log('[Crear Campa√±a] Response ok:', resCamp.ok);
            console.log('[Crear Campa√±a] Response headers:', Object.fromEntries(resCamp.headers.entries()));

            const campData = await resCamp.json().catch((err) => {
              console.error('[Crear Campa√±a] Error al parsear JSON:', err);
              return {
                ok: false,
                message: 'Error al crear campa√±a',
              };
            });

            console.log('[Crear Campa√±a] Datos recibidos (campData):', JSON.stringify(campData, null, 2));
            console.log('[Crear Campa√±a] campData.ok:', campData.ok);
            console.log('[Crear Campa√±a] campData.data:', campData.data);

            if (!resCamp.ok || !campData.ok) {
              const message = campData.message || 'Error al crear campa√±a';
              console.error('[Crear Campa√±a] Error en respuesta:', message);
              throw new Error(message);
            }

            const campaignId =
              (campData.data && campData.data.campaign && (campData.data.campaign._id || campData.data.campaign.id)) ||
              (campData.data && (campData.data.campaignId || campData.data.id)) ||
              null;
            
            console.log('[Crear Campa√±a] Campaign ID extra√≠do:', campaignId);
            console.log('[Crear Campa√±a] Estructura completa de campData.data:', campData.data);

            if (segmentStatusEl) {
              segmentStatusEl.textContent =
                'Campa√±a creada correctamente.' + (campaignId ? ' ID: ' + campaignId : '');
              segmentStatusEl.style.color = '#22c55e';
            }

            createCampaignBtn.textContent = 'Campa√±a creada';
          } catch (err) {
            console.error('Error al crear campa√±a:', err);
            if (segmentStatusEl) {
              // Crear un mensaje de error m√°s visual y formateado
              const errorMessage = err.message || 'Error al crear campa√±a';
              
              // Detectar si es un error de l√≠mite de campa√±as
              const isLimitError = errorMessage.includes('l√≠mite') || errorMessage.includes('alcanzado');
              
              if (isLimitError) {
                // Formato especial para errores de l√≠mite
                segmentStatusEl.innerHTML = `
                  <div style="
                    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
                    border: 1px solid rgba(239, 68, 68, 0.3);
                    border-radius: 12px;
                    padding: 16px;
                    margin-top: 12px;
                    display: flex;
                    align-items: flex-start;
                    gap: 12px;
                    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.1);
                  ">
                    <div style="
                      font-size: 24px;
                      line-height: 1;
                      flex-shrink: 0;
                    ">‚ö†Ô∏è</div>
                    <div style="flex: 1;">
                      <div style="
                        font-weight: 600;
                        font-size: 14px;
                        color: #fca5a5;
                        margin-bottom: 6px;
                      ">L√≠mite de campa√±as alcanzado</div>
                      <div style="
                        font-size: 13px;
                        color: var(--text-muted);
                        line-height: 1.5;
                      ">${errorMessage}</div>
                    </div>
                  </div>
                `;
              } else {
                // Formato est√°ndar para otros errores
                segmentStatusEl.innerHTML = `
                  <div style="
                    background: rgba(239, 68, 68, 0.1);
                    border: 1px solid rgba(239, 68, 68, 0.3);
                    border-radius: 8px;
                    padding: 12px;
                    margin-top: 12px;
                    color: #fca5a5;
                    font-size: 13px;
                  ">
                    <strong>Error:</strong> ${errorMessage}
                  </div>
                `;
              }
            }
          } finally {
            // Restaurar estado al finalizar (√©xito o error)
            isCreatingCampaign = false;
            createCampaignBtn.disabled = false;
            createCampaignBtn.textContent = 'üöÄ Crear campa√±a';
          }
          }
        });
      }
    }

    async function sendQuestion() {
      const questionInput = document.getElementById("question-input");
      const statusEl = document.getElementById("rag-status");
      const askBtn = document.getElementById("ask-btn");
      const resultsBox = document.getElementById("results");
      const answerEl = document.getElementById("answer-text");
      const contextEl = document.getElementById("context-list");

      const question = (questionInput.value || "").trim();

      if (!selectedPdfId) {
        statusEl.textContent = "Selecciona un DOC primero en la lista de la izquierda.";
        return;
      }

      if (!question) {
        statusEl.textContent = "Escribe una pregunta antes de enviar.";
        return;
      }

      try {
        statusEl.textContent = "Consultando RAG...";
        askBtn.disabled = true;
        
        // Limpiar respuesta anterior y mostrar √°rea de resultados con animaci√≥n
        answerEl.innerHTML = "";
        resultsBox.style.display = "block";
        // Forzar reflow para que la animaci√≥n funcione
        resultsBox.offsetHeight;

        const res = await fetchWithAuth("/api/rag/query", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            pdfId: selectedPdfId,
            question,
          }),
        });

        const data = await res.json();

        if (!res.ok || !data.ok) {
          throw new Error(data.message || "Error en la consulta RAG");
        }

        statusEl.textContent = "Respuesta recibida.";

        // Guardar en cache esta respuesta para este PDF
        saveLastRagResponse(selectedPdfId, question, data.data);

        // Renderizar respuesta (texto + tabla + botones) desde data.data
        renderRagResponseFromData(data.data);
        
        // üî• Limpiar textarea y devolver el foco
        questionInput.value = "";
        questionInput.focus();
        
        // Auto-scroll al final del contenido despu√©s de renderizar
        setTimeout(() => {
          const wrapper = document.querySelector('.answer-content-wrapper');
          if (wrapper) {
            wrapper.scrollTop = wrapper.scrollHeight;
          }
          // Tambi√©n hacer scroll suave de la p√°gina si es necesario
          resultsBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);

        // Secci√≥n de contexto oculta - no procesar chunks
        // contextEl.innerHTML = "";
        // const ctx = Array.isArray(data.context) ? data.context : [];
        // if (!ctx.length) {
        //   const li = document.createElement("li");
        //   li.textContent = "No se devolvi√≥ contexto.";
        //   contextEl.appendChild(li);
        // } else {
        //   ctx.slice(0, 4).forEach((chunk, idx) => {
        //     const li = document.createElement("li");
        //     const preview = (chunk.content || "")
        //       .slice(0, 200)
        //       .replace(/\s+/g, " ");
        //     li.innerHTML = `<strong>#${idx + 1}${
        //       typeof chunk.index === "number" ? ` (chunk ${chunk.index})` : ""
        //     }:</strong> <code>${preview}...</code>`;
        //     contextEl.appendChild(li);
        //   });
        // }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error al consultar RAG: " + err.message;
        answerEl.innerHTML = `<p style="color: #ef4444;">Error: ${err.message}</p>`;
        resultsBox.style.display = "block";
      } finally {
        askBtn.disabled = false;
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const askBtn = document.getElementById("ask-btn");
      askBtn.addEventListener("click", sendQuestion);

      const questionInput = document.getElementById("question-input");
      questionInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          sendQuestion();
        }
      });

      loadPdfs();
    });

    // Sidebar functionality
    document.addEventListener('DOMContentLoaded', () => {
      const menuToggle = document.getElementById('menuToggle');
      const sidebar = document.getElementById('sidebar');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarClose = document.getElementById('sidebarClose');
      const sidebarUserName = document.getElementById('sidebarUserName');
      const navUserName = document.getElementById('navUserName');

      // Sincronizar nombre de usuario en sidebar
      if (navUserName && sidebarUserName) {
        const updateSidebarUser = () => {
          sidebarUserName.textContent = navUserName.textContent;
        };
        updateSidebarUser();
        // Observar cambios en el nombre de usuario
        const observer = new MutationObserver(updateSidebarUser);
        observer.observe(navUserName, { childList: true, subtree: true });
      }

      // Marcar p√°gina activa seg√∫n la URL actual
      const currentPath = window.location.pathname;
      const sidebarLinks = sidebar.querySelectorAll('.sidebar-menu-link');
      sidebarLinks.forEach(link => {
        const linkPath = new URL(link.href).pathname;
        if (linkPath === currentPath) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });

      function openSidebar() {
        sidebar.classList.add('active');
        sidebarOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      function closeSidebar() {
        sidebar.classList.remove('active');
        sidebarOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Abrir sidebar
      if (menuToggle) {
        menuToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          openSidebar();
        });
      }

      // Cerrar sidebar
      if (sidebarClose) {
        sidebarClose.addEventListener('click', closeSidebar);
      }

      // Cerrar al hacer click en overlay
      if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', closeSidebar);
      }

      // Cerrar al hacer click en un link del men√∫
      sidebarLinks.forEach(link => {
        link.addEventListener('click', () => {
          // Peque√±o delay para que se vea la navegaci√≥n
          setTimeout(closeSidebar, 100);
        });
      });

      // Cerrar con ESC
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('active')) {
          closeSidebar();
        }
      });
    });
  </script>
</body>
</html>


